 #pragma once

#include <exception>
#include <iostream>
#include <utility>

namespace bmstu
{
// срздаём шаблонный класс с типом данных T. при вызове функции компилятор
// заменит Т на конкретный аргумент указанного пользователем типа
template <typename T>
class stack
{
   public:
  stack() = default;     // конструктор
  ~stack() { clear(); }  // диструктор

  bool empty() const noexcept { return size_ == 0; }  // пуст ли

  size_t size() const noexcept { return size_; }  // размер

  template <typename... Args>   // троеточие используется, когда шаблон может
                 // принимать любое число параметров.
                 void emplace(Args&&... args)  //
  {
    T* new_data = get_new();
    new (&new_data[size_]) T(std::forward<Args>(
      args)...);  // в нашем случае нью создаёт объект уже в выделенной
            // памяти по указоннуму адресу, а не выделяет новую.
    // форвард позволяет передавать элементы сохраняя их значения рвалью и
    // лвалью. троеточие распаковывает пакет аргс
    // грубо говоря тут мы поочереди перекидываем элементы из даты в нью
    // дату сохраняя рвалью и лвалью
    operator delete(data_);   // вызываем оператор очищающий память
    data_ = new_data;  // в ранее очищенную дату закидываем новую дату
    size_++;
  }

  void clear() noexcept
  {
    for (size_t i = 0; i < size_; ++i)  // проходимся по стеку

    {
      T* ptr = &data_[i];   // обращаемся к элементу
      ptr->~T();       // вызывыаем диструктор
    }
    operator delete(data_);   // очищаем память
    data_ = nullptr;  // значение даты - пустой указатель
    size_ = 0;
  }

  void push(const T& value)
  {
    emplace(value);
  }  // метот эмплейс позволяет создать новый элемент в контейнере

  void push(T&& value)
  {
    emplace(std::move(value));
  }  // используя мув мы перемещаем элементы, а не копируем их, это быстрее

  void pop()  // убираем элемент массива. по идее стоило бы возвращать этот
        // элемент, однако функция типо войд, значит возвращать не стоит
  {
    if (empty())
    {
      throw std::underflow_error(
        "Stack is empty");  // исключительная ситуация, если стек пустой
    }
    data_[size_ - 1].~T();  // обращаемся к последнему элементу стека и
                // вызываем диструктор
    --size_;  // уменьшаем размер стека
  }

  T& top()  // для рвалью
  {
    if (empty())
    {
      throw std::underflow_error(
        "Stack is empty");  // исключительная ситуация, если стек пустой
    }
    else
    {
      return data_[size_ - 1];  // возвращаем последний элемент стека
    }
  }

  const T& top() const  // для лвалью
  {
    if (empty())
    {
      throw std::underflow_error(
        "Stack is empty");  // исключительная ситуация, если стек пустой
    }
    else
    {
      return data_[size_ - 1];
    }
  }

   private:
  T* data_ = nullptr;   // по умолчанию стек пуст
  size_t size_ = 0;   // размер стека так же нулевой

  T* get_new()
  {
    T* new_data = static_cast<T*>(operator new(
      sizeof(T) *
      (size_ + 1)));  // создаём новую дату типа Т. Оператор нью выделяет
              // блок памяти из кучи и даёт указатель на него
    // сайзоф с указателем на размер стека плюс один определяет колличество
    // байтов нужных для хранения элементов статик каст даёт новый тип Т
    // вместо войд, который вернул оператор нью чтобы он соответствовал типу
    // нью дата
    for (size_t i = 0; i < size_; i++)  // пробегаемся по стеку
    {
      new (&new_data[i]) T(
        std::move(data_[i]));  // перемещаем элемент из даты в нью дату
      data_[i].~T();  // вызываем диструктор к элементу даты
    }
    return new_data;
  }
};
}  // namespace bmstu

// & - это ссылка, а && - rvalue ссылка, которая позволяет не копировать объект
// noexcept означает что компилятору не следует проверять исключения и тратить
// на это время. используется тогда, когда известен тот факт, что исключений
// нет.
// nullptr - пустой указатель. используется в С++ вместо NULL с 2011 года. NULL
// всё ещё работает, не считается менее корректным.
